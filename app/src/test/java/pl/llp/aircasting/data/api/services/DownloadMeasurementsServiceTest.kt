package pl.llp.aircasting.data.api.services

import com.appmattus.kotlinfixture.Context
import com.appmattus.kotlinfixture.decorator.constructor.ConstructorStrategy
import com.appmattus.kotlinfixture.decorator.constructor.constructorStrategy
import com.appmattus.kotlinfixture.kotlinFixture
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.runTest
import org.junit.Test
import org.mockito.kotlin.any
import org.mockito.kotlin.doAnswer
import org.mockito.kotlin.doReturn
import org.mockito.kotlin.eq
import org.mockito.kotlin.mock
import org.mockito.kotlin.times
import org.mockito.kotlin.verify
import pl.llp.aircasting.data.api.response.MeasurementResponse
import pl.llp.aircasting.data.api.response.SessionStreamResponse
import pl.llp.aircasting.data.api.response.SessionStreamWithMeasurementsResponse
import pl.llp.aircasting.data.api.response.SessionWithMeasurementsResponse
import pl.llp.aircasting.data.local.entity.MeasurementDBObject
import pl.llp.aircasting.data.local.entity.MeasurementStreamDBObject
import pl.llp.aircasting.data.local.entity.SessionDBObject
import pl.llp.aircasting.data.local.entity.SessionWithStreamsAndMeasurementsDBObject
import pl.llp.aircasting.data.local.entity.StreamWithMeasurementsDBObject
import pl.llp.aircasting.data.local.repository.ActiveSessionMeasurementsRepository
import pl.llp.aircasting.data.local.repository.MeasurementStreamsRepository
import pl.llp.aircasting.data.local.repository.MeasurementsRepository
import pl.llp.aircasting.data.local.repository.SessionsRepository
import pl.llp.aircasting.data.model.Session
import pl.llp.aircasting.util.DateConverter
import pl.llp.aircasting.util.helpers.services.AveragingWindow
import pl.llp.aircasting.util.helpers.services.MeasurementsAveragingHelper
import java.util.Date
import kotlin.reflect.KClass
import kotlin.reflect.KFunction
import kotlin.reflect.full.primaryConstructor

@OptIn(ExperimentalCoroutinesApi::class)
class DownloadMeasurementsServiceTest {
    private val dispatcher = StandardTestDispatcher()
    private val dataClassConstructorStrategy = object : ConstructorStrategy {
        override fun constructors(context: Context, obj: KClass<*>): Collection<KFunction<*>> {
            return listOf(obj.primaryConstructor!!)
        }
    }
    private val dataClassFixture = kotlinFixture {
        constructorStrategy(dataClassConstructorStrategy)
    }
    private val autoGeneratedDefaultStreamId = 0L
    private val uuid = dataClassFixture<String>()
    private lateinit var session: SessionDBObject
    private val localSensorName = "local"
    private lateinit var sessionStream: MeasurementStreamDBObject
    private val localSensorNameToDelete = "toDelete"
    private lateinit var sessionStreamToDelete: MeasurementStreamDBObject
    private lateinit var streamWithMeasurements: StreamWithMeasurementsDBObject
    private lateinit var streamWithMeasurementsToDelete: StreamWithMeasurementsDBObject
    private lateinit var sessionWithStreamsAndMeasurementsDBObject: SessionWithStreamsAndMeasurementsDBObject
    private lateinit var sessionsRepository: SessionsRepository

    private lateinit var measurementResponse: MeasurementResponse
    private lateinit var sessionStreamWithMeasurementsResponse: SessionStreamWithMeasurementsResponse
    private lateinit var streamsResponses: HashMap<String, SessionStreamWithMeasurementsResponse>
    private lateinit var sessionWithMeasurementsResponse: SessionWithMeasurementsResponse
    private lateinit var apiService: ApiService
    private lateinit var measurementsStreamRepository: MeasurementStreamsRepository
    private val averagingWindow = AveragingWindow.ZERO
    private lateinit var averagingHelper: MeasurementsAveragingHelper
    private lateinit var activeSessionMeasurementsRepository: ActiveSessionMeasurementsRepository
    private lateinit var measurementsRepository: MeasurementsRepository

    @Test
    fun when_downloadMeasurements_forFixed_deletesStreamsByComparingSensorNamesOnly() =
        runTest(dispatcher) {
            setup()
            val testSubject = DownloadMeasurementsService(
                apiService = apiService,
                errorHandler = mock(),
                sessionsRepository = sessionsRepository,
                measurementStreamsRepository = measurementsStreamRepository,
                measurementsRepository = measurementsRepository,
                activeMeasurementsRepository = activeSessionMeasurementsRepository,
                dispatcher = dispatcher,
                averagingHelper = averagingHelper,
            )

            testSubject.downloadMeasurements(session.uuid)

            verify(sessionsRepository).getSessionWithMeasurementsByUUID(session.uuid)
            verify(apiService).downloadFixedMeasurements(eq(session.uuid), any())
            verify(measurementsStreamRepository).delete(eq(listOf(sessionStreamToDelete)))
        }

    @Test
    fun when_downloadMeasurements_forFixed_insertsNewMeasurementsForExistingStream() =
        runTest(dispatcher) {
            setup()
            val testSubject = DownloadMeasurementsService(
                apiService = apiService,
                errorHandler = mock(),
                sessionsRepository = sessionsRepository,
                measurementStreamsRepository = measurementsStreamRepository,
                measurementsRepository = measurementsRepository,
                activeMeasurementsRepository = activeSessionMeasurementsRepository,
                dispatcher = dispatcher,
                averagingHelper = averagingHelper,
            )

            testSubject.downloadMeasurements(session.uuid)

            verify(sessionsRepository).getSessionWithMeasurementsByUUID(session.uuid)
            verify(apiService).downloadFixedMeasurements(eq(session.uuid), any())
            verify(measurementsRepository).insertAll(
                eq(autoGeneratedDefaultStreamId),
                eq(session.id),
                eq(
                    MeasurementsFactory.get(
                        sessionStreamWithMeasurementsResponse.measurements,
                        averagingWindow.value,
                        session.isExternal
                    )
                )
            )
        }

    @Test
    fun when_downloadMeasurements_forFixed_followed_insertsMeasurementsToActiveMeasurementsTable() =
        runTest(dispatcher) {
            setup()
            val testSubject = DownloadMeasurementsService(
                apiService = apiService,
                errorHandler = mock(),
                sessionsRepository = sessionsRepository,
                measurementStreamsRepository = measurementsStreamRepository,
                measurementsRepository = measurementsRepository,
                activeMeasurementsRepository = activeSessionMeasurementsRepository,
                dispatcher = dispatcher,
                averagingHelper = averagingHelper,
            )

            testSubject.downloadMeasurements(session.uuid)

            verify(sessionsRepository).getSessionWithMeasurementsByUUID(session.uuid)
            verify(apiService).downloadFixedMeasurements(eq(session.uuid), any())
            verify(activeSessionMeasurementsRepository).createOrReplaceMultipleRows(
                eq(autoGeneratedDefaultStreamId),
                eq(session.id),
                eq(
                    MeasurementsFactory.get(
                        sessionStreamWithMeasurementsResponse.measurements,
                        averagingWindow.value,
                        session.isExternal
                    )
                )
            )
        }

    @Test
    fun when_downloadMeasurements_forFixed_updatesSessionEndTime() =
        runTest(dispatcher) {
            setup()
            val testSubject = DownloadMeasurementsService(
                apiService = apiService,
                errorHandler = mock(),
                sessionsRepository = sessionsRepository,
                measurementStreamsRepository = measurementsStreamRepository,
                measurementsRepository = measurementsRepository,
                activeMeasurementsRepository = activeSessionMeasurementsRepository,
                dispatcher = dispatcher,
                averagingHelper = averagingHelper,
            )

            testSubject.downloadMeasurements(session.uuid)

            verify(sessionsRepository).getSessionWithMeasurementsByUUID(session.uuid)
            verify(apiService).downloadFixedMeasurements(eq(session.uuid), any())
            verify(sessionsRepository).update(
                eq(session.copy(endTime = DateConverter.fromString(sessionWithMeasurementsResponse.end_time)))
            )
        }

    @Test
    fun when_downloadMeasurements_forMobile_doesNotUpdateMeasurementsIfTheyArePresentInDB() =
        runTest(dispatcher) {
            setup(dataClassFixture<SessionDBObject> {
                property(SessionDBObject::uuid) { uuid }
                property(SessionDBObject::type) { Session.Type.MOBILE }
                property(SessionDBObject::isExternal) { false }
                property(SessionDBObject::followedAt) { null }
            }, sessionMeasurements = listOf(dataClassFixture<MeasurementDBObject>()))
            val testSubject = DownloadMeasurementsService(
                apiService = apiService,
                errorHandler = mock(),
                sessionsRepository = sessionsRepository,
                measurementStreamsRepository = measurementsStreamRepository,
                measurementsRepository = measurementsRepository,
                activeMeasurementsRepository = activeSessionMeasurementsRepository,
                dispatcher = dispatcher,
                averagingHelper = averagingHelper,
            )

            testSubject.downloadMeasurements(session.uuid)

            verify(sessionsRepository).getSessionWithMeasurementsByUUID(session.uuid)
            verify(apiService).downloadSessionWithMeasurements(eq(session.uuid), any())
            verify(sessionsRepository, times(0)).update(any<SessionDBObject>())
            verify(measurementsRepository, times(0)).insertAll(any(), any(), any())
            verify(activeSessionMeasurementsRepository, times(0)).createOrReplaceMultipleRows(
                any(),
                any(),
                any()
            )
            verify(measurementsStreamRepository, times(0)).getIdOrInsert(
                any(),
                any<MeasurementStreamDBObject>()
            )
        }

    @Test
    fun when_downloadMeasurements_forMobile_deletesNotPresentStreamsEvenIfThereAreMeasurementsInDB() =
        runTest(dispatcher) {
            setup(dataClassFixture<SessionDBObject> {
                property(SessionDBObject::uuid) { uuid }
                property(SessionDBObject::type) { Session.Type.MOBILE }
                property(SessionDBObject::isExternal) { false }
                property(SessionDBObject::followedAt) { null }
            }, sessionMeasurements = listOf(dataClassFixture<MeasurementDBObject>()))
            val testSubject = DownloadMeasurementsService(
                apiService = apiService,
                errorHandler = mock(),
                sessionsRepository = sessionsRepository,
                measurementStreamsRepository = measurementsStreamRepository,
                measurementsRepository = measurementsRepository,
                activeMeasurementsRepository = activeSessionMeasurementsRepository,
                dispatcher = dispatcher,
                averagingHelper = averagingHelper,
            )

            testSubject.downloadMeasurements(session.uuid)

            verify(sessionsRepository).getSessionWithMeasurementsByUUID(session.uuid)
            verify(apiService).downloadSessionWithMeasurements(eq(session.uuid), any())
            verify(measurementsStreamRepository).delete(eq(listOf(sessionStreamToDelete)))
        }

    @Test
    fun when_downloadMeasurements_forMobile_updatesMeasurementsIfTheyAreNOTPresentInDB() =
        runTest(dispatcher) {
            setup(
                dataClassFixture<SessionDBObject> {
                    property(SessionDBObject::uuid) { uuid }
                    property(SessionDBObject::type) { Session.Type.MOBILE }
                    property(SessionDBObject::isExternal) { false }
                    property(SessionDBObject::followedAt) { null }
                },
                sessionMeasurements = emptyList(),
                sessionMeasurementsToDelete = emptyList()
            )
            val testSubject = DownloadMeasurementsService(
                apiService = apiService,
                errorHandler = mock(),
                sessionsRepository = sessionsRepository,
                measurementStreamsRepository = measurementsStreamRepository,
                measurementsRepository = measurementsRepository,
                activeMeasurementsRepository = activeSessionMeasurementsRepository,
                dispatcher = dispatcher,
                averagingHelper = averagingHelper,
            )

            testSubject.downloadMeasurements(session.uuid)

            verify(sessionsRepository).getSessionWithMeasurementsByUUID(session.uuid)
            verify(apiService).downloadSessionWithMeasurements(eq(session.uuid), any())
            verify(measurementsStreamRepository).delete(eq(listOf(sessionStreamToDelete)))
            verify(sessionsRepository).update(
                eq(session.copy(endTime = DateConverter.fromString(sessionWithMeasurementsResponse.end_time)))
            )
            verify(measurementsRepository).insertAll(
                eq(autoGeneratedDefaultStreamId),
                eq(session.id),
                eq(
                    MeasurementsFactory.get(
                        sessionStreamWithMeasurementsResponse.measurements,
                        averagingWindow.value,
                        session.isExternal
                    )
                )
            )
            verify(activeSessionMeasurementsRepository, times(0)).createOrReplaceMultipleRows(
                any(), any(), any()
            )
        }


    private fun setup(
        sessionConfig: SessionDBObject = dataClassFixture<SessionDBObject> {
            property(SessionDBObject::uuid) { uuid }
            property(SessionDBObject::type) { Session.Type.FIXED }
            property(SessionDBObject::isExternal) { true }
            property(SessionDBObject::followedAt) { Date() }
        },
        sessionMeasurements: List<MeasurementDBObject> = listOf(),
        sessionMeasurementsToDelete: List<MeasurementDBObject> = listOf(dataClassFixture<MeasurementDBObject>()),
    ) {
        session = sessionConfig
        sessionStream = dataClassFixture<MeasurementStreamDBObject> {
            property(MeasurementStreamDBObject::sessionId) { session.id }
            property(MeasurementStreamDBObject::deleted) { false }
            property(MeasurementStreamDBObject::sensorName) { localSensorName }
        }
        sessionStreamToDelete = dataClassFixture<MeasurementStreamDBObject> {
            constructorStrategy(dataClassConstructorStrategy)
            property(MeasurementStreamDBObject::sessionId) { session.id }
            property(MeasurementStreamDBObject::deleted) { false }
            property(MeasurementStreamDBObject::sensorName) { localSensorNameToDelete }
        }
        streamWithMeasurements =
            StreamWithMeasurementsDBObject(
                sessionStream, measurements = sessionMeasurements
            )
        streamWithMeasurementsToDelete = dataClassFixture<StreamWithMeasurementsDBObject> {
            property(StreamWithMeasurementsDBObject::stream) { sessionStreamToDelete }
            property(StreamWithMeasurementsDBObject::measurements) { sessionMeasurementsToDelete }
        }
        sessionWithStreamsAndMeasurementsDBObject =
            dataClassFixture<SessionWithStreamsAndMeasurementsDBObject> {
                property(SessionWithStreamsAndMeasurementsDBObject::session) { session }
                property(SessionWithStreamsAndMeasurementsDBObject::streams) {
                    listOf(
                        streamWithMeasurements,
                        streamWithMeasurementsToDelete
                    )
                }
            }
        sessionsRepository = runBlocking {
            mock<SessionsRepository> {
                on(it.getSessionWithMeasurementsByUUID(eq(session.uuid))) doReturn sessionWithStreamsAndMeasurementsDBObject
            }
        }
        measurementResponse = dataClassFixture<MeasurementResponse> {
            property(MeasurementResponse::time) { Date().let { DateConverter.toDateString(it) } }
        }
        sessionStreamWithMeasurementsResponse =
            dataClassFixture<SessionStreamWithMeasurementsResponse> {
                property(SessionStreamResponse::sensorName) { localSensorName }
                property(SessionStreamWithMeasurementsResponse::sensorName) { localSensorName }
                property(SessionStreamWithMeasurementsResponse::measurements) {
                    listOf(measurementResponse)
                }
                property(SessionStreamResponse::deleted) { false }
            }
        streamsResponses =
            hashMapOf("streamToStay" to sessionStreamWithMeasurementsResponse)
        sessionWithMeasurementsResponse =
            dataClassFixture<SessionWithMeasurementsResponse> {
                property(SessionWithMeasurementsResponse::streams) { streamsResponses }
                property(SessionWithMeasurementsResponse::end_time) {
                    DateConverter.toDateString(Date())
                }
            }
        apiService = runBlocking {
            when (session.type) {
                Session.Type.MOBILE -> {
                    mock<ApiService> {
                        on(
                            it.downloadSessionWithMeasurements(
                                eq(session.uuid),
                                any()
                            )
                        ) doReturn sessionWithMeasurementsResponse
                    }
                }

                Session.Type.FIXED -> {
                    mock<ApiService> {
                        on(
                            it.downloadFixedMeasurements(
                                eq(session.uuid),
                                any()
                            )
                        ) doReturn sessionWithMeasurementsResponse
                    }
                }
            }
        }
        measurementsStreamRepository = runBlocking {
            mock<MeasurementStreamsRepository> {
                on(it.getIdOrInsert(any(), any<MeasurementStreamDBObject>())) doAnswer {
                    (it.arguments[1] as MeasurementStreamDBObject).let { stream ->
                        stream.id
                    }
                }
            }
        }
        averagingHelper = mock<MeasurementsAveragingHelper> {
            on(it.calculateAveragingWindow(any(), any())) doReturn averagingWindow
        }
        activeSessionMeasurementsRepository = mock<ActiveSessionMeasurementsRepository>()
        measurementsRepository = mock<MeasurementsRepository>()
    }
}